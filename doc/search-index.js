var searchIndex = {};
searchIndex["custom_derive"] = {"doc":"This crate provides a macro that enables the use of custom `derive` attributes.","items":[],"paths":[]};
searchIndex["newtype_derive"] = {"doc":"This crate provides several macros for deriving implementations of various traits for &quot;newtype&quot; wrappers (*i.e.* tuple structs with a single element).  That is, given a tuple struct with exactly one field (*e.g.* `struct Buckets(i32)`), these macros will derive &quot;obvious&quot; implementations of traits such as `Add`, `Neg`, `Index`, `Deref`, `From`, etc.","items":[[14,"NewtypeAdd!","newtype_derive","",null,null],[14,"NewtypeAddAssign!","","",null,null],[14,"NewtypeBitAnd!","","",null,null],[14,"NewtypeBitAndAssign!","","",null,null],[14,"NewtypeBitOr!","","",null,null],[14,"NewtypeBitOrAssign!","","",null,null],[14,"NewtypeBitXor!","","",null,null],[14,"NewtypeBitXorAssign!","","",null,null],[14,"NewtypeDiv!","","",null,null],[14,"NewtypeDivAssign!","","",null,null],[14,"NewtypeMul!","","",null,null],[14,"NewtypeMulAssign!","","",null,null],[14,"NewtypeRem!","","",null,null],[14,"NewtypeRemAssign!","","",null,null],[14,"NewtypeSub!","","",null,null],[14,"NewtypeSubAssign!","","",null,null],[14,"NewtypeShl!","","",null,null],[14,"NewtypeShlAssign!","","",null,null],[14,"NewtypeShr!","","",null,null],[14,"NewtypeShrAssign!","","",null,null],[14,"NewtypeNeg!","","",null,null],[14,"NewtypeNot!","","",null,null],[14,"NewtypeDeref!","","",null,null],[14,"NewtypeDerefMut!","","",null,null],[14,"NewtypeIndex!","","",null,null],[14,"NewtypeIndexMut!","","",null,null],[14,"NewtypeFrom!","","",null,null],[14,"NewtypeBinary!","","",null,null],[14,"NewtypeDebug!","","",null,null],[14,"NewtypeDisplay!","","",null,null],[14,"NewtypeLowerExp!","","",null,null],[14,"NewtypeLowerHex!","","",null,null],[14,"NewtypeOctal!","","",null,null],[14,"NewtypePointer!","","",null,null],[14,"NewtypeUpperExp!","","",null,null],[14,"NewtypeUpperHex!","","",null,null]],"paths":[]};
searchIndex["enum_derive"] = {"doc":"This crate provides several macros for deriving some useful methods for unitary enums (*i.e.* enums where variants do not have payloads).","items":[[3,"ParseEnumError","enum_derive","This is the error type used for derived implementations of `FromStr` for unitary enums.",null,null],[11,"eq","","",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"fmt","","",0,null],[11,"description","","",0,null],[14,"IterVariants!","","",null,null],[14,"IterVariantNames!","","",null,null],[14,"NextVariant!","","",null,null],[14,"PrevVariant!","","",null,null],[14,"EnumDisplay!","","",null,null],[14,"EnumFromStr!","","",null,null],[14,"EnumFromInner!","","",null,null],[14,"EnumInnerAsTrait!","","",null,null]],"paths":[[3,"ParseEnumError"]]};
initSearch(searchIndex);
